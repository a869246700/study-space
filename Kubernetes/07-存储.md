## 七、存储

### 7.1 ConfigMap

#### 7.1.1 ConfigMap的创建方式

> 方式一 使用目录创建

```shell
$ ls docs/user-guide/configmap/kubectl
game.properties
ui.properties

$ cat /home/configmap/kubectl/game.properties
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

$ cat /home/configmap/kubectl/ui.properties
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice

# 创建configmap
$ kubectl create configMap game-confog --from-file=/home/configmap/kubectl
# 查看configmap的详细信息
$ kubectl get cm -o yaml game-config 
$ kubectl describe configmaps game-config
```

`--from-file`指定在目录下的所有文件都会被用在 **ConfigMap** 里面创建一个键值对。键的名字就是文件名，值就是文件的内容



> 方式二 使用文件创建

只要指定为一个文件就可以从单个文件中创建 **ConfigMap**

```shell
$ kubectl create configmap game-config-2 --from-file=/home/configmap/kubectl/game.properties
$ kubectl get cm -o yaml game-config-2
```



> 方式三 使用字面量创建

使用文字值创建，利用`--from-literal`参数传递配置信息，该参数可以使用多次，格式如下

```shell
$ kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm
$ kubectl get cm -o yaml special-config
```



#### 7.1.2 Pod中使用ConfigMap

> 一 使用 ConfigMap 来代替环境变量

```yaml
# vim special.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  specail.how: very
  specail.type: charm
```

```yaml
# vim env.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config
  namespace: default
data:
  log.level: INFO
```

```yaml
# vim pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: hub.yyq.com/library/myapp:v1
      command: ["/bin/sh", "-c", "env"]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
      envFrom:
        - configMapRef:
            name: env-config
  restartPolicy: Never
```

```shell
$ kubectl create -f special.yaml
$ kubectl create -f env.yaml
$ kubectl create -f pod.yaml
$ kubectl logs dapi-test-pod
```



> 二 使用 ConfigMap 设置命令行参数

```yaml
# vim special.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  specail.how: very
  specail.type: charm
```

```yaml
# vim pod2.yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod2
spec:
  containers:
    - name: test-container
      image: hub.yyq.com/library/myapp:v1
      command: ["/bin/sh", "-c", "echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)"]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
      envFrom:
        - configMapRef:
            name: env-config
  restartPolicy: Never
```

```shell
$ kubectl create -f special.yaml
$ kubectl create -f pod2.yaml
$ kubectl logs dapi-test-pod2
```



> 三 通过数据卷插件使用 ConfigMap

```yaml
# vim special.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  specail.how: very
  specail.type: charm
```

```yaml
# vim pod3.yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod3
spec:
  containers:
    - name: test-container
      image: hub.yyq.com/library/myapp:v1
      command: ["/bin/sh", "-c", "cat /etc/config/special.how"]
      volumeMounts:
        - name: config-volume
          mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap: 
        name: special-config
  restartPolicy: Never
```



#### 7.1.3 ConfigMap 热更新

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: log-config
  namespace: default
data:
  log_level: INFO
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: my-nginx
spec:
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
        - name: my-nginx
          image: hub.yyq.com/library/myapp:v1
          ports:
            - containerPort: 80
          volumeMounts:
            - name: config-volume
              mountPath: /etc/config
      volumes:
        - name: config-volume
          configMap:
            name: log-config
```

**修改 ConfigMap**

```shell
$ kubectl edit configmap log-config
```

**修改`log_level`的值为`DEBUG`，等待大概10秒钟时间，再次查看环境变量的值**

```shell
$ kubectl exec -it my-nginx-57d7f8b475-f64nj -- cat /etc/config/log_level
```



> 注意点

**ConfigMap 更新后滚动更新 Pod**

更新ConfigMap目前并不会触发相关Pod的滚动更新.可以通过修改pod annotations的方式强制触发滚动更新

```shell
$ kubectl patch deployment my-nginx --patch '{ "template": { "metadata": { "annotations": { "version/config": "20220102" }}}}'
```



**更新 ConfigMap 后**

* 使用该 ConfigMap 挂载的 Env 不会同步更新
* 使用该 ConfigMap 挂载的 Volume 中的数据需要一端时间（实测大概10秒）才能同步更新



### 7.2 Secret

**Secret解决了密码、token. 密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者PodSpec中。Secret 可以以Volume或者环境变量的方式使用**



Secret有三种类型:

* Service Account: 用来访问Kubernetes API,由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes. io/serviceaccount目录中

* Opaque: base64编码格式的Secret, 用来存储密码、密钥等

* kubernetes.io/dockerconfigjson: 用来存储私有docker registry的认证信息



#### 7.2.1 Service Account

Service Account用来访问Kubernetes API,由Kubernetes自动创建，并且会自动挂载到Pod的`/run/secrets/kubernetes.io/serviceaccount`目录中

```shell
$ kubectl run nginx --image nginx
deployment "nginx" created

$ kubectl get pod

$ kubectl exec nginx-xxxx ls /run/secrets/kubernetes.io/serviceaccount
ca.crt
namespace
token
```



#### 7.2.2 Opaque

> 一、创建说明

**Opaque类型的数据是一个map类型，要求vatue是base64编码格式:**

```shell
$ echo -n "admin" | base64
YWRtaW4=
$ echo -m "1f2d1e2e67df" | base64
MWYyZDFlMmU2N2Rm
```

**secrets.yaml**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```



> 二、使用方式

**1. 将 Secret 挂载到 Volume 中**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-test
  labels:
    name: secret-test
spec:
  containers:
    - name: db
      image: hub.yyq.com/library/myapp:v1
      volumeMounts:
        - name: secrets
          mountPath: /etc/secrets
          readOnly: true
  volumes:
    - name: secrets
      secret:
        secretName: mysecret
```

**2. 将 Secret 导出到环境变量中**

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: pod-deployment
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: pod-deployment
    spec:
      restartPolicy: Never
      containers:
        - name: pod-1
          image: hub.yyq.com/library/myapp:v1
          ports:
            - containerPort: 8
          env:
            - name: TEST_USER
              valueFrom:
                secretKeyRef:
                  name: mysecret
                  key: username
            - name: TEST_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysecret
                  key: password
```



#### 7.2.3 kubernetes.io/dockerconfigjson

使用 Kuberctl 创建 `docker registry` 认证的 secret

```shell
$ kubectl create secret docker-registry myregistrykey --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL
secret "myregistrykey" created.
```

在创建Pod的时候，通过 `imagePullsecrets` 来引用刚创建的`myregistrykey`

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo
spec:
  containers:
    - name: foo
      image: hub.yyq.com/test/myapp:v1
  imagePullSecrets:
    - name: myregistrykey
```



### 7.3 Volume

容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现-些问题。首先，当容器崩溃时，kubelet会重启它，但是容器中的文件将丢失--容器以干净的状态 (镜像最初的状态)重新启动。其次,在 Pod 中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的 volume 抽象就很好的解决了这些问题



> 背景

Kubernetes中的卷有明确的寿命一一与封装它的 Pod相同。所f以,卷的生命比Pod中的所有容器都长，当这个容器重启时数据仍然得以保存。当然，当Pod不再存在时，卷也将不复存在。也许更重要的是, Kubernetes支持多种类型的卷，Pod 可以同时使用任意数量的卷



#### 7.3.1 卷的类型

**Kubernetes 支持以下类型的卷：**

* `awsElasticBlockStore` `azureDisk` `azureFile` `cephfs` `csi` `downwardAPI` `emptyDir`
* `fc` `flocker` `gcePersistentDisk` `gitRepol` `glusterfs` `hostPath` `iscsi` `local` `nfs`
* `persistentVolumeClaim` `projected` `portworxvolume` `quobytel` `rbd` `scaleI0` `secret`
* `storageos` `vsphereVolume`



#### 7.3.2 emptyDir

当Pod被分配给节点时，首先创建 emptyDir 卷,并且只要该Pod在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入emptyDir 卷中的相同文件,尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除Pod时，emptyDir 中的数据将被永久删除

<!--注意:容器崩溃不会从节点中移除pod,因此、emptyDir 、卷中的数据在容器崩溃时是安全的-->

**用法**

* 暂存空间，例如用于基于磁盘的合并排序
* 用作长时间计算崩溃恢复时的检查点
* Web服务器容器提供数据时，保存内容管理器容器提取的文件

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  containers:
    - name: test-container
      image: hub.yyq.com/library/myapp:v1
      volumeMounts:
        - name: cache-volume
          mountPath: /cache
    - name: liveness-exec-container
      image: busybox
      imagePullPolicy: IfNotPresent
      command: ["/bin/sh", "-c", "touch /tmp/live; sleep 60; rm -rf /tmp/live; sleep 3600"]
  volumes:
    - name: cache-volume
      emptyDir: {}
```



#### 7.3.3 hostPth

`hostPath`卷将主机节点的文件系统中的文件或目录挂载到集群中



`hostPath`的用途如下:

* 运行需要访问 Docker 内部的容器;使用 `/var/1ib/docker` 的 `hostPath`
* 在容器中运行 cAdvisor; 使用 `/dev/cgroups` 的 `hostPath`



除了所需的 `path` 属性之外，用户还可以为 `hostPath` 卷指定 `type`

| 值                | 行为                                                         |
| ----------------- | ------------------------------------------------------------ |
|                   | 空字符串(默认)用于向后兼容，这意味着在挂载hostPath卷之前不会执行任何检查。 |
| DirectoryOrCreate | 如果在给定的路径上没有任何东西存在，那么将根据需要在那里创建一个空目录， 权限设置为0755，与Kubelet具有相同的组和所有权。 |
| Directory         | 给定的路径下必须存在目录                                     |
| FileOrCreate      | 如果在给定的路径上没有任何东西存在，那么会根据需要创建一个空文件， 权限设置为0644，与Kubelet具有相同的组和所有权。 |
| File              | 给定的路径下必须存在文件                                     |
| Socket            | 给定的路径下必须存在UNIX套接字                               |
| CharDevice        | 给定的路径下必须存在字符设备                                 |
| BlockDevice       | 给定的路径下必须存在块设备                                   |

**使用这种卷类型是请注意,因为:**

* 于每个节点上的文件都不同，具賄相同配置(例如从podTemplate创建的)的pod在不同节点上的行为可能会有所不同
* 当Kubernetes按照计划添加资源感知调度时，将无法考虑hostPath 使用的资源
* 在底层主机上创建的文件或目录只能由root写入。您需要在特权容器中以root身份运行进程,或修改主机上的文件权限以便写入 hostPath卷



```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-hostpath
spec:
  containers:
    - name: test-container
      image: hub.yyq.com/library/myapp:v1
      volumeMounts:
        - name: hostpath-volume
          mountPath: /test-hostpath
  volumes:
    - name: hostpath-volume
      hostPath:
        path: /data
        type: Directory
```





### prsistent Volume

